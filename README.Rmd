---
output:
  md_document:
    variant: markdown_github
---

<!-- README.md is generated from README.Rmd. Please edit that file -->

```{r, echo = FALSE}
knitr::opts_chunk$set(
  collapse = TRUE,
  comment = "# ",
  fig.path = "figures/README-",
  dpi = 250
)
```

<!-- NOTE: you have to kill any R M2 process before knitting this. -->


# __m2r__

__m2r__ is a very new R package that provides a persistent connection between [R](https://www.r-project.org) and [Macaulay2](http://www.math.uiuc.edu/Macaulay2/).

The package grew out of a collaboration at the [2016 Mathematics Research Community](http://www.ams.org/programs/research-communities/mrc-16), funded by the [National Science Foundation](http://www.nsf.gov) through the [American Mathematical Society](http://www.ams.org/home/page). 

It is currently being actively developed, so expect changes. If you have a feature request, please file an issue!








## Getting started

__m2r__ is loaded like any other R package:
```{r load_m2}
library(m2r)
```

When loaded, __m2r__ initializes a persistent connection to a back-end Macaulay2 session.  The basic function in R that accesses this connection is `m2()`, which simply accepts a character string that is run by the Macaulay2 session.

```{r basic_connection}
m2("1 + 1")
```

You can see the persistence by setting variables and accessing them across different `m2()` calls:

```{r persistence}
m2("a = 1")
m2("a")
```

Apart from the basic connection to M2, __m2r__ has basic data structures and methods to reference and manipulate the M2 objects within R.  These are being actively developed.










## Rings, ideals, and Grobner bases

__m2r__ currently has basic support for [rings](https://en.wikipedia.org/wiki/Ring_(mathematics)):

```{r ring_definition}
(R <- ring(c("t", "x", "y", "z"), "QQ"))
```

You can compute [Grobner bases](https://en.wikipedia.org/wiki/GrÃ¶bner_basis) as well.  The basic function to do this is `gb()`:
```{r basic_grobner}
gb("t^4 - x", "t^3 - y", "t^2 - z", ring = R)
```
The result is an `mpolyList` object, from the [__mpoly__ package](https://github.com/dkahle/mpoly).  You can see the M2 code by adding `code = TRUE`:
```{r grobner_code}
gb("t^4 - x", "t^3 - y", "t^2 - z", code = TRUE)
```

You can compute the basis respective of different orders as follows.  The default ordering is the [grevlex order](https://en.wikipedia.org/wiki/Monomial_order) on the variables given by `mpoly::vars()` applied to the `mpolyList` given by the polynomials.
```{r grobner_order}
R <- ring(c("x","y","t","z"), order = "lex")
gb("t^4 - x", "t^3 - y", "t^2 - z", ring = R)
```


`gb()` also accepts `mpoly` objects, like `gb(p1, p2, p3)` where `p1`, `p2`, and `p3` are `mpoly` objects (e.g. `p1 <- mp("t^4 - x")`).  There is also a [standard evaluation](http://adv-r.had.co.nz/Computing-on-the-language.html) version of `gb()` called `gb_()`, which takes in a `mpolyList` object directly.
```{r grobner_standard}
(ps <- mp(c("t^4 - x", "t^3 - y", "t^2 - z")))
gb_(ps)
```



## Additional features




### Factor integers

```{r factor_n}
(x <- 2^5 * 3^4 * 5^3 * 7^2 * 11^1)
factor_n(x)
```



### Smith normal form of a matrix

The Smith normal form of a matrix _M_ here refers to the decomposition of an integer matrix _D = PMQ_, where _D_, _P_, and _Q_ are integer matrices and _D_ is diagonal. _P_ and _Q_ are unimodular matrices (their determinants are -1 or 1), so they are invertible.  This is somewhat like a singular value decomposition for integer matrices.

```{r snf}
M <- matrix(c(
   2,  4,   4,
  -6,  6,  12,
  10, -4, -16
), nrow = 3, byrow = TRUE)

(mats <- snf(M))
P <- mats$P; D <- mats$D; Q <- mats$Q

P %*% M %*% Q                # = D
solve(P) %*% D %*% solve(Q)  # = M

det(P)
det(Q)
```


## Creating your own __m2r__ wrapper

To create your own wrapper function of something in Macaulay2, you'll need to create an R file that looks like the one below.  This will create both value (e.g. `f`) and reference/pointer (e.g. `f.`) versions of the function. As a good example of these at work, see the scripts for [`factor_n()`](https://github.com/musicman3320/m2r/blob/master/R/factor_n.R) or [`factor_poly()`](https://github.com/musicman3320/m2r/blob/master/R/factor_poly.R).

```{r creating-your-own, eval=FALSE}
#' Function documentation header
#'
#' Function header explanation, can run several lines. Function
#' header explanation, can run several lines. Function header
#' explanation, can run several lines.
#'
#' @param esntl_parm_1 esntl_parm_1 description
#' @param esntl_parm_2 esntl_parm_2 description
#' @param code return only the M2 code? (default: \code{FALSE})
#' @param parse_parm_1 parse_parm_1 description
#' @param parse_parm_2 parse_parm_2 description
#' @param ... ...
#' @name f
#' @return (value version) parsed output or (reference/dot version)
#'   \code{m2_pointer}
#' @examples
#'
#' \dontrun{ requires Macaulay2 be installed
#'
#' # put examples here
#' 1 + 1
#'
#' }
#'





# value version of f (standard user version)
#' @rdname f
#' @export
f <- function(esntl_parm_1, esntl_parm_2, code = FALSE, parse_parm_1, parse_parm_2, ...) {

  # run m2
  args <- as.list(match.call())[-1]
  eargs <- lapply(args, eval, envir = parent.frame())
  pointer <- do.call(f., eargs)
  if(code) return(invisible(pointer))

  # parse output
  parsed_out <- m2_parse(pointer)

  # more parsing
  TRUE

  # return
  TRUE

}




# reference version of f (returns pointer to m2 object)
#' @rdname f
#' @export
f. <- function(esntl_parm_1, esntl_parm_2, code = FALSE, ...) {

  # basic arg checking
  TRUE

  # create essential parameters to pass to m2 this step regularizes input to m2, so it
  # is the one that deals with pointers, chars, rings, ideals, mpolyLists, etc.
  TRUE

  # construct m2_code from regularized essential parameters
  TRUE

  # message
  if(code) { message(m2_code); return(invisible(m2_code)) }

  # run m2 and return pointer
  m2.(m2_code)

}
```


## Acknowledgements

  This material is based upon work supported by the National Science Foundation under [Grant No. 1321794](http://nsf.gov/awardsearch/showAward?AWD_ID=1321794).

## Installation

Here's how you can install this _very developmental_ version of __m2r__.  Remember you need to have [Macaulay2](http://www.math.uiuc.edu/Macaulay2/) downloaded; __m2r__ will look for it in your path variable (in the terminal, `echo $PATH`) as set by `~/.bash_profile` or, if nonexistent, then `~/.bashrc`, then `~/.profile`.

```R
# install.packages("devtools")
devtools::install_github("musicman3320/m2r")
```
