% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/ideal.R
\name{ideal}
\alias{ideal}
\alias{ideal_}
\alias{ideal_.}
\alias{print.m2_ideal}
\alias{radical}
\alias{radical.}
\alias{saturate}
\alias{saturate.}
\alias{primary_decomposition}
\alias{primary_decomposition.}
\alias{dimension}
\title{Create a new ideal in Macaulay2}
\usage{
ideal(..., ring, raw_chars = FALSE, code = FALSE)

ideal_(x, ring, raw_chars = FALSE, code = FALSE, ...)

ideal_.(x, ring, raw_chars = FALSE, code = FALSE, ...)

\method{print}{m2_ideal}(x, ...)

radical(ideal, code = FALSE, ...)

radical.(ideal, code = FALSE, ...)

saturate(ideal, saturate_by, code = FALSE, ...)

saturate.(ideal, saturate_by, code = FALSE, ...)

primary_decomposition(ideal, code = FALSE, ...)

primary_decomposition.(ideal, code = FALSE, ...)

dimension(ideal, code = FALSE, ...)
}
\arguments{
\item{...}{...}

\item{ring}{the referent ring in Macaulay2}

\item{raw_chars}{if \code{TRUE}, the character vector will not be
parsed by \code{\link{mp}}, saving time (default:
\code{FALSE}). the down-side is that the strings must be
formated for M2 use directly, as opposed to for
\code{\link{mp}}. (e.g. \code{"x*y+3"} instead of \code{"x y +
3"})}

\item{code}{return only the M2 code? (default: \code{FALSE})}

\item{x}{a listing of polynomials. several formats are accepted,
see examples.}

\item{ideal, saturate_by}{an ideal object of class \code{m2_ideal} or
\code{m2_ideal_pointer}}
}
\value{
a reference to a Macaulay2 ideal
}
\description{
Create a new ideal in Macaulay2
}
\examples{

\dontrun{ requires Macaulay2

ring(c("x","y"), coefring = "QQ")
ideal("x+y", "x^2+y^2", ring = QQxy)

(QQxy <- ring(c("x","y"), coefring = "QQ"))
(QQxyz <- ring(c("x","y","z"), coefring = "QQ"))

# standard evaluation version
ideal_(   c("x+y", "x^2+y^2") , QQxy)
ideal_(mp(c("x+y", "x^2+y^2")), QQxy)

ideal_(mp(c("x+y", "x^2+y^2")), QQxy, code = TRUE)

(QQxy. <- ring.(c("x","y"), coefring = "QQ"))
ideal_(   c("x+y", "x^2+y^2") , QQxy.)
ideal_(mp(c("x+y", "x^2+y^2")), QQxy.)

I  <- ideal_ (c("x+y", "x^2+y^2"), QQxy.)
I. <- ideal_.(c("x+y", "x^2+y^2"), QQxy.)
is.m2_ideal(I)
is.m2_ideal(I.)
is.m2_ideal_pointer(I)
is.m2_ideal_pointer(I.)

# radical
QQxy <- ring(c("x","y"), "QQ")
I <- ideal_(c("(x^2 + 1)^2 y", "y + 1"))
radical(I)
radical.(I)

# dimension
ring(c("x","y","z"), "QQ")
I <- ideal_(c("(x^2 + 1)^2 y", "y + 1"))
dimension(I)

I <- ideal_("y - (x+1)", ring(c("x", "y"), "QQ")) # a line
dimension(I)

I <- ideal_("z - (x+y+1)", ring(c("x", "y", "z"), "QQ")) # a plane
dimension(I)


# saturation
QQxy <- ring(c("x", "y", "z"), "QQ")
I <- ideal_(c("x^2", "y^4", "z + 1"))
J <- ideal_("x^6")
saturate(I)
saturate.(I)
saturate(I, J)
saturate(I, mp("x"))
saturate(I, "x")


saturate(ideal_("x y", ring(c("x", "y"), "QQ")), "x^2")

ring("x", "QQ")
I <- ideal("(x-1) x (x+1)") # solution over R is x = -1, 0, 1
saturate(I, "x") # remove x = 0 from solution
ideal("(x-1) (x+1)")

# primary_decomposition
QQxy <- ring(c("x","y"), "QQ")
I <- ideal("(x^2 + 1) (x^2 + 2)", "y + 1")
primary_decomposition(I)
primary_decomposition.(I)

I <- ideal("x (x + 1)", "y")
primary_decomposition(I)

I <- ideal("x^2", "x y")
primary_decomposition(I)

}
}
