% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/gb.R
\name{gb}
\alias{gb}
\alias{gb_}
\alias{gb_.}
\title{Compute a Grobner basis with Macaulay2}
\usage{
gb(..., ring, degree_limit, raw_chars = FALSE, code = FALSE)

gb_(x, ring, degree_limit, raw_chars = FALSE, code = FALSE, ...)

gb_.(x, ring, degree_limit, raw_chars = FALSE, code = FALSE, ...)
}
\arguments{
\item{...}{...}

\item{ring}{if \code{x} is an ideal, \code{ring} need not be
specified.}

\item{degree_limit}{parameter that stops computation after
S-polynomials have reached a given degree. Only meaningful in
homogeneous case.}

\item{raw_chars}{if \code{TRUE}, the character vector will not be
parsed by \code{\link{mp}}, saving time (default:
\code{FALSE}). the down-side is that the strings must be
formated for M2 use directly, as opposed to for
\code{\link{mp}}. (e.g. \code{"x*y+3"} instead of \code{"x y +
3"})}

\item{code}{return only the M2 code? (default: \code{FALSE})}

\item{x}{a character vector of polynomials to be parsed by
\code{\link{mp}}, a \code{mpolyList} object, an
\code{\link{ideal}} or pointer to an ideal}
}
\value{
an mpolyList object
}
\description{
Compute a Grobner basis with Macaulay2
}
\details{
\code{gb} uses nonstandard evaluation; \code{gb_} is the standard
evaluation equivalent.
}
\examples{

\dontrun{ requires Macaulay2 be installed


##### basic usage
########################################

# the last ring evaluated is the one used in the computation
(QQtxyz <- ring(c("t","x","y","z"), coefring = "QQ"))
gb("t^4 - x", "t^3 - y", "t^2 - z")
gb("t^4 - x", "t^3 - y", "t^2 - z", code = TRUE)

# standard evaluation version
gb_(c("t^4 - x", "t^3 - y", "t^2 - z"))

# different rings
(QQxyzt <- ring(c("x","y","z","t"), coefring = "QQ"))
gb("t^4 - x", "t^3 - y", "t^2 - z")

# you can specify a specific ring apart from the last used
# (this resets what the last used ring is)
gb("t^4 - x", "t^3 - y", "t^2 - z", ring = QQtxyz)
gb("t^4 - x", "t^3 - y", "t^2 - z")

# gb of an ideal
(QQtxyz <- ring(c("t","x","y","z"), coefring = "QQ"))
I <- ideal(c("t^4 - x", "t^3 - y", "t^2 - z"), QQtxyz)
gb(I)


##### more advanced usage
########################################

# defining a ring on the fly
gb_(c("t^4 - x", "t^3 - y", "t^2 - z"), ring = "QQ[t,x,y,z]")
gb_(c("t^4 - x", "t^3 - y", "t^2 - z"), ring = "QQ[t,x,y,z]", code = TRUE)

# interaction with pointers
(QQtxyz. <- ring.(c("t","x","y","z"), coefring = "QQ"))
gb_(c("t^4 - x", "t^3 - y", "t^2 - z"), ring = QQtxyz., code = TRUE)

I <- ideal(c("t^4 - x", "t^3 - y", "t^2 - z"), QQtxyz.)
gb_(I)

I. <- ideal.(c("t^4 - x", "t^3 - y", "t^2 - z"), QQtxyz.)
gb_(I.)


##### still broken
########################################

gb("x*y", "x*z", "x", raw_chars = TRUE)






gb_(mp(c("x y - z^2", "y^2 - w^2")))

gb(c("x y-z^2", "y^2-w^2"), ring = "QQ[w,x,y,z]")
gb(mp("x y-z^2"), mp("y^2-w^2"), ring = "QQ[w,x,y,z]")
gb(mp("x y-z^2"), mp("y^2-w^2"), degree_limit = 2)






# standard evaluation
gb_.(   c("t^4 - x", "t^3 - y", "t^2 - z") , "QQ[t,x,y,z]")
gb_.(mp(c("t^4 - x", "t^3 - y", "t^2 - z")), "QQ[t,x,y,z]")
gb_.(mp(c("t^4 - x", "t^3 - y", "t^2 - z")), code = TRUE)
gb_.(   c("t^4 - x", "t^3 - y", "t^2 - z") , "QQ[t,x,y,z]", degree_limit = 2)



gb_(   c("t^4 - x", "t^3 - y", "t^2 - z") , "QQ[t,x,y,z]")



(QQtxyz <- ring(c("t", "x","y","z"), coefring = "QQ"))
gb_.(mp(c("t^4 - x", "t^3 - y", "t^2 - z")), QQtxyz, code = TRUE)
gb_.(mp(c("t^4 - x", "t^3 - y", "t^2 - z")), QQtxyz)
gb_.(   c("t^4 - x", "t^3 - y", "t^2 - z") , QQtxyz)
gb_.(   c("t^4 - x", "t^3 - y", "t^2 - z") , "QQ[t,x,y,z]", code = TRUE)
gb_.(   c("t^4 - x", "t^3 - y", "t^2 - z") , "QQ[t,x,y,z]")
gb_(c("t^4 - x", "t^3 - y", "t^2 - z"))
gb_(ideal("t^4 - x", "t^3 - y", "t^2 - z"))
gb_(c("t^4 - x", "t^3 - y", "t^2 - z"), raw_chars = TRUE)



}
}
\seealso{
\code{\link{mp}}
}

